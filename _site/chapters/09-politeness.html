<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Social reasoning about social reasoning</title>
  <link rel="stylesheet" href="https://yui.yahooapis.com/pure/0.6.0/pure-min.css">
  <link rel="stylesheet" href="/probLang/assets/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  <!-- <link rel="stylesheet" href="/probLang/assets/css/editor.css"> -->
  <!-- <link rel="stylesheet" href="/probLang/assets/css/webppl-viz.css"> -->
  <link rel="stylesheet" href="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-editor-1.0.1.css">
  <link rel="stylesheet" href="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-viz-0.7.6.css">
  <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
  <link rel="canonical" href="http://gscontras.github.io/probLang/probLang/chapters/09-politeness.html">
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script>
  <script src="/probLang/assets/js/parse-bibtex.js"></script>
  <script src="/probLang/assets/js/main.js"></script>
  <!-- <script src="/probLang/assets/js/webppl-editor.js"></script> -->
  <!-- <script src="/probLang/assets/js/webppl-viz.js"></script>   -->
  <!-- <script src="/probLang/assets/js/webppl.min.js" defer async></script> -->
  <script src="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-editor-1.0.9.js"></script>
  <script src="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-viz-0.7.11.js"></script>
  <script src="https://s3-us-west-2.amazonaws.com/cdn.webppl.org/webppl-v0.9.7.js" defer async></script>
</head>


  <body>

    <header class="site-header">
  <a class="site-title" href="/probLang/">Probabilistic languge understanding</a>

  <a class="site-subtitle">An introduction to the Rational Speech Act framework</a>

  <a class="site-authors">By Gregory Scontras and Michael Henry Tessler</a>
</header>


    <div class="page-content-wrapper">
      <div class="page-content">
        <h1 class="chapter-title">Social reasoning about social reasoning</h1>

<h3 id="chapter-9-politeness">Chapter 9: Politeness</h3>

<p>When using language, speakers aim to get listeners to believe the things that they believe.
But sometimes, we don’t want listeners to know <em>exactly</em> how we feel.
Imagine your date bakes you a batch of flax seed, sugar-free, gluten-free cookies before your big presentation next week.
(What a sweetheart.)
You are grateful for them—something to take your mind off impending doom.
But then you bite into them, and you wonder if they actually qualify as cookies and not just fragments of seed glued together.
Your date asks you what you think.
You look up and say “They’re good.”</p>

<p>Politeness violates a critical principle of cooperative communication: exchanging information efficiently and accurately.
If information transfer were the only currency in communication, a cooperative speaker would find polite utterances undesirable because they are potentially misleading.
But polite language use is critical to making sure your date doesn’t charge out of the room before you can qualify what you meant by the more truthful and informative “These cookies are terrible.”</p>

<p>Brown and Levinson (1987) recast the notion of a cooperative speaker as one who has both an epistemic goal to correctly update the listener’s knowledge state, as well as a social goal to minimize any potential damage to the hearer’s (and the speaker’s own) self-image, which they called <em>face</em>.
<a href="http://langcog.stanford.edu/papers_new/yoon-2016-cogsci.pdf">Yoon, Tessler, et al. (2016)</a> formalize a version of this idea in the RSA framework by introducing a new component to the speaker’s utility function: social utility.</p>

<h3 id="a-new-speaker">A new speaker</h3>

<p>The usual speaker utility from RSA is a surprisal-based, epistemic utility:</p>

<script type="math/tex; mode=display">U_{epistemic}(w; s) = \ln(P_{L_0}(s \mid w))</script>

<p>Social utility can be defined as the expected subjective utility of the state the listener would infer given the utterance <script type="math/tex">w</script>:</p>

<script type="math/tex; mode=display">U_{social}(w; s) = \mathbb{E}_{P_{L_0}(s \mid w)}[V(s)]</script>

<p>where <script type="math/tex">V</script> is a value function that maps states to subjective utility values — this captures the affective consequences for the listener of being in state <script type="math/tex">s</script>.</p>

<p>Speaker utility is then a mixture of these components:</p>

<script type="math/tex; mode=display">U(w; s; \phi) = \phi \cdot U_{epistemic} + (1 - \phi) \cdot U_{social}</script>

<p>Note that at this point, we do not differentiate subjective state value to the listener from subjective state value to the speaker, though in many situations these could in principle be different.
Also at this point, we do not allow for <em>deception</em> or <em>meanness</em>, which would be the exact opposite of epistemic and social utilities, respectively — though this could very naturally be incorporated. (In reft:yoonetal2016, they do investigate <em>meanness</em> by having independent weights on the two utilities. For simplicity, we adopt the notation of reft:yoonetal2017, in which they describe utility as a simpler mixture-model.)</p>

<p><!-- [Yoon et al. 2017](http://langcog.stanford.edu/papers_new/yoon-2017-cogsci.pdf) --></p>

<p>In WebPPL, this looks like the following:</p>

<pre><code>var utility = {
  epistemic: literalListener.score(state),
  social: expectation(literalListener, valueFunction)
};
var speakerUtility = phi * utility.epistemic + (1 - phi) * utility.social
</code></pre>

<p><code>expectation</code> computes the expected value (or mean) of the distribution supplied to it as the first argument.
The second argument is an optional <em>projection function</em>, for when you want the expectation computed with respect to some transformation of the distribution (technically: a transformation of the support of the distribution).
Here, <code>valueFunction</code> projects the listener’s distribution from world states onto subjective valuations of those world states (e.g., the subjective value of a listener believing the cookies they baked were rated 4.5 out of a possible 5 stars).</p>

<p>We consider a simplified case study of the example given at the beginning, shown in the Figure 1 below.
The listener has completed some task or produced some product (e.g., baked a cake), and solicits the speaker’s feedback.
Performance on the task maps to a scale ranging from 1 to 5 hearts (shown below; cf. online product reviews).
These are the states of the world that the speaker can be informative with respect to.
Below, the speaker thinks the cake deserves 3 out of 5 hearts.</p>

<p><img src="../images/yoon-hearts.jpeg" alt="Fig. 1: Politeness case study" style="width: 400px;" /></p>
<center>Figure 1: Politeness case study.</center>

<p>At the same time, these states of the world also have some inherent subjective value: 5 hearts is better than 3 hearts.
<code>phi</code> governs how much the speaker seeks to communicate information about the state vs. make the listener believe she is a highly valued state.</p>

<p>We start with a literal listener whose task is to interpret value judgments (e.g., “terrible,” “okay,” “amazing”) according to their literal semantics.</p>

<pre><code>var states = [1,2,3,4,5]
var utterances = ["terrible","bad","okay","good","amazing"]

// correspondence of utterances to states (empirically measured)
var literalSemantics = {
  "terrible":[.95,.85,.02,.02,.02],
  "bad":[.85,.95,.02,.02,.02],
  "okay":[0.02,0.25,0.95,.65,.35],
  "good":[.02,.05,.55,.95,.93],
  "amazing":[.02,.02,.02,.65,0.95]
}

// determine whether the utterance describes the state
// by flipping a coin with the literalSemantics weight
// ... state - 1 because of 0-indexing
var meaning = function(utterance, state){
  return flip(literalSemantics[utterance][state - 1]);
};

// literal listener
var listener0 = function(utterance) {
  Infer({model: function(){
    var state = uniformDraw(states);
    var m = meaning(utterance, state);
    condition(m);
    return state;
  }})
};

</code></pre>

<blockquote>
  <p><strong>Exercise:</strong> Test the predictions of <code>listener0</code> for the various utterances.</p>
</blockquote>

<p>Next, we add in the speaker, who reasons about the literal listener with respect to an epistemic and a social goal.</p>

<pre><code>// state prior, utterance prior, and meaning function
///fold:
var states = [1,2,3,4,5]
var utterances = ["terrible","bad","okay","good","amazing"]

// correspondence of utterances to states (empirically measured)
var literalSemantics = {
  "terrible":[.95,.85,.02,.02,.02],
  "bad":[.85,.95,.02,.02,.02],
  "okay":[0.02,0.25,0.95,.65,.35],
  "good":[.02,.05,.55,.95,.93],
  "amazing":[.02,.02,.02,.65,0.95]
}

// determine whether the utterance describes the state
// by flipping a coin with the literalSemantics weight
// ... state - 1 because of 0-indexing
var meaning = function(utterance, state){
  return flip(literalSemantics[utterance][state - 1]);
};
///

// value function scales social utility by a parameter lambda
var lambda = 1.25 // value taken from MAP estimate from Yoon, Tessler, et al. 2016
var valueFunction = function(s){
  return lambda * s
};

// literal listener
var listener0 = function(utterance) {
  Infer({model: function(){
    var state = uniformDraw(states);
    var m = meaning(utterance, state);
    condition(m);
    return state;
  }})
};

var alpha = 10; // MAP estimate from Yoon, Tessler, et al. 2016
var speaker1 = function(state, phi) {
  Infer({model: function(){

    var utterance = uniformDraw(utterances);
    var L0_posterior = listener0(utterance);

    var utility = {
      epistemic: L0_posterior.score(state),
      social: expectation(L0_posterior, valueFunction)
    };

    var speakerUtility = phi * utility.epistemic +
                        (1 - phi) * utility.social

    factor(alpha * speakerUtility)

    return utterance;
  }})
};

speaker1(1, 0.99)
</code></pre>

<blockquote>
  <p><strong>Exercises</strong>:</p>
</blockquote>

<blockquote>
  <ol>
    <li>Describe the kind of speaker assumed by the above function call (<code>speaker(1, 0.99)</code>)?</li>
    <li>Change the call to the speaker to make it so that it only cares about making the listener feel good.</li>
    <li>Change the call to the speaker to make it so that it cares about both making the listener feel good and conveying information.</li>
    <li>Change the value of <code>lambda</code> and examine the results.</li>
  </ol>
</blockquote>

<h3 id="a-listener-who-understands-politeness">A listener who understands politeness</h3>

<p>If different speakers can have different weights on the mixture parameter <code>phi</code>, which governs the trade-off between kindness and informativity, listeners may have uncertainty about what kind of speaker they are interacting with. (Relatedly, we should be able to interpret the kindness vs. informativity behind a single utterance, for a known speaker.) This can be captured by endowing the <code>pragmaticListener</code> with a prior distribution over <code>phi</code>, corresponding to uncertainty about the parameter of the speaker’s utility function.</p>

<pre><code>///fold:
var states = [1,2,3,4,5]
var utterances = ["terrible","bad","okay","good","amazing"]

// correspondence of utterances to states (empirically measured)
var literalSemantics = {
  "terrible":[.95,.85,.02,.02,.02],
  "bad":[.85,.95,.02,.02,.02],
  "okay":[0.02,0.25,0.95,.65,.35],
  "good":[.02,.05,.55,.95,.93],
  "amazing":[.02,.02,.02,.65,0.95]
}

// determine whether the utterance describes the state
// by flipping a coin with the literalSemantics weight
// ... state - 1 because of 0-indexing
var meaning = function(utterance, state){
  return flip(literalSemantics[utterance][state - 1]);
};

// value function scales social utility by a parameter lambda
var lambda = 1.25 // value taken from MAP estimate from Yoon, Tessler, et al. 2016
var valueFunction = function(s){
  return lambda * s
};

// literal listener
var listener0 = cache(function(utterance) {
  Infer({model: function(){
    var state = uniformDraw(states);
    var m = meaning(utterance, state);
    condition(m);
    return state;
  }})
});

var alpha = 10; // MAP estimate from Yoon, Tessler, et al. 2016
var speaker1 = cache(function(state, phi) {
  Infer({model: function(){

    var utterance = uniformDraw(utterances);
    var L0_posterior = listener0(utterance);

    var utility = {
      epistemic: L0_posterior.score(state),
      social: expectation(L0_posterior, valueFunction)
    };

    var speakerUtility = phi * utility.epistemic +
                        (1 - phi) * utility.social

    factor(alpha * speakerUtility);

    return utterance;
  }})
});
///
var pragmaticListener = function(utterance) {
  Infer({model: function(){

    var state = uniformDraw(states)
    var phi = uniformDraw([0.1, 0.3, 0.5, 0.7, 0.9])
    var S1 = speaker1(state, phi)

    observe(S1, utterance)

    return { state, phi }

  }})
}

var listenerPosterior = pragmaticListener("good")

display("expected state = " +
        expectation(marginalize(listenerPosterior, "state")))
viz(marginalize(listenerPosterior, "state"))

display("expected phi = " +
        expectation(marginalize(listenerPosterior, "phi")))
viz.density(marginalize(listenerPosterior, "phi"))
</code></pre>

<p>Above, we have a listener who hears that they did “good” and infers how well they actually did, as well as how much the speaker values honesty vs. kindness.</p>

<blockquote>
  <p><strong>Exercises</strong>:</p>
</blockquote>

<blockquote>
  <ol>
    <li>Examine the marginal posteriors on <code>state</code>. Does this make sense? Compare it to what the <code>literalListener</code> would believe upon hearing the same utterance.</li>
    <li>Examine the marginal posterior on <code>phi</code>. Does this make sense? Consider a different utterance: would <code>pragmaticListener</code> infer something different about <code>phi</code>? Test your intuitions by running that utterance through the <code>pragmaticListener</code>.</li>
    <li>In Yoon, Tessler, et al. (2016), the authors ran an experiment testing participants’ intuitions as to the kind of speaker they were dealing with (i.e., inferred <code>phi</code>). Modify <code>pragmaticListener</code> so that she knows the speaker (a) wants the listener to feel good, (b) wants to convey information to the listener, and (c) both, and test the models on the utterance “good”.</li>
    <li>The authors also ran an experiment testing participants’ intuitions if they knew what state of the world they were in. Modify <code>pragmaticListener</code> so that she knows what state of the world she is in. Come up with your own interesting situations (i.e., choose a state and an utterance) and show the model predictions. Are the predictions in accord with your intuitions? Why or why not?</li>
  </ol>
</blockquote>

<h3 id="politeness-with-indirect-speech-acts">Politeness with indirect speech acts</h3>

<p>Above, we modeled the case study of <strong>white lies</strong>, utterances which are used to convey misleading information for purposes of politeness. There are other ways to be polite, however. Speakers may be deliberately <strong>indirect</strong> for considerations of politeness. Consider a listener who just gave an objectively terrible presentation. They look fragile as they come to you for your feedback. You tell them “It wasn’t amazing.”</p>

<p>Why would somebody produce such an indirect speech act? If the speaker wanted to actually be nice, they would say “It was fine.” or “It was great.” If the speaker wanted to actually convey information, they would say “It was terrible.” reft:yoonetal2017 hypothesize that speakers produce indirect speech acts in order to <em>appear</em> to care both about conveying information and saving the listener’s face. Can we elaborate the model above to account for politeness by being indirect? First, we will have to consider a speaker model, who produces utterances that can be understand as polite.</p>

<pre><code>var speaker2 = function(state, phi) {
  Infer({model: function(){

    var utterance = sample(utterancePrior)
    var L1 = pragmaticListener(utterance)
    factor(alpha2 * L1.score({state, phi}))
    return utterance

  }})
}
</code></pre>

<p>The <code>pragmaticListener</code> model is the one defined in the case study above, a listener who reasons both about the true state and the speaker’s goals (specifically, <code>phi</code>). Now, we have a speaker (<code>speaker2</code>) who produces utterances in order to get the pragmatic listener to believe a certain true state and <code>phi</code>. That is, the above speaker has a “self-presentational” goal.</p>

<p>To look at <em>indirectness</em>, we will add utterances with <strong>negation</strong>, which are indirect insofar as they convey less information than their positive form (e.g., “not amazing” is potentially true of 1 - 4 hearts).
<!-- Here is the full politeness model from [Yoon et al. (2017)](http://langcog.stanford.edu/papers_new/yoon-2017-underrev.pdf): --></p>

<pre><code>///fold:
// helper function split utterances at "_" to find negation
var isNegation = function(utt){
  return (utt.split("_")[0] == "not")
};

var reshapeUtt = function(utt){
  return {
    negation: (utt.split("_")[0] == "not") ? "not": "",
    adjective: utt.split("_")[1]
  }
};

// helper function to round
var round = function(x){
  return Math.round(x * 100) / 100
}

// possible utterances (both positive and negative)
var utterances = [
  "yes_terrible","yes_bad","yes_okay","yes_good","yes_amazing",
  "not_terrible","not_bad","not_okay","not_good","not_amazing"
];

// utterance costs (negative utterance more expensive)
var cost_yes = 0;
var cost_neg = 1;

var uttCosts = map(function(u) {
  return isNegation(u) ? Math.exp(-cost_neg) : Math.exp(-cost_yes)
}, utterances)

// utterance prior
var utterancePrior = Infer({model: function(){
  return categorical({
    vs: utterances,
    ps: uttCosts
  })
}});

// taken from literal semantics expt
var literalSemantics = {
  "not_amazing": [0.9925, 0.9186, 0.7876, 0.2321, 0.042],
  "not_bad": [0.0075, 0.2897, 0.8514, 0.8694, 0.8483],
  "not_good": [0.9926, 0.8871, 0.1582, 0.0073, 0.0081],
  "not_okay": [0.9198, 0.7652, 0.1063, 0.0074, 0.1192],
  "not_terrible": [0.0415, 0.4363, 0.9588, 0.9225, 0.9116],
  "yes_amazing": [0.0077, 0.0077, 0.0426, 0.675, 0.9919],
  "yes_bad": [0.9921, 0.9574, 0.0078, 0.0078, 0.0079],
  "yes_good": [0.008, 0.0408, 0.8279, 0.9914, 0.993],
  "yes_okay": [0.0078, 0.286, 0.9619, 0.7776, 0.6122],
  "yes_terrible": [0.9593, 0.5217, 0.0753, 0.008, 0.044]
};

var meaning = function(words, state){
  return flip(literalSemantics[words][state - 1]);
};

// value function scales social utility by a parameter lambda
var lambda = 1.25 // value taken from MAP estimate from Yoon, Tessler, et al. 2016
var valueFunction = function(s){
  return lambda * s
};

// possible states of the world (cf. Yelp reviews)
var states = [1,2,3,4,5];

// info for epistemic vs. social utility prior;
// 1 corresponds to fully favoring epistemic utility
var weightBins = map(round, _.range(0,1, 0.05))

// literal listener
var literalListener = cache(function(utterance) {
  Infer({model: function(){
    var state = uniformDraw(states)
    var m = meaning(utterance, state)
    condition(m)
    return state
  }})
})

var alpha = 10; // MAP estimate from Yoon, Tessler, et al. 2016
var speaker1 = cache(function(state, phi) {
  Infer({model: function(){
    var utterance = sample(utterancePrior)
    var L0_posterior = literalListener(utterance)
    var utility = {
      epistemic: L0_posterior.score(state),
      social: expectation(L0_posterior, valueFunction)
    };
    var speakerUtility = phi * utility.epistemic +
                        (1 - phi) * utility.social
    factor(alpha * speakerUtility)
    return utterance;
  }})
});
///

// pragmatic listener
// infers the state and the speaker's goals (i.e., phi)
var pragmaticListener = cache(function(utterance) {
  Infer({model: function(){

    var state = uniformDraw(states)
    var phi = uniformDraw(weightBins)
    var S1 = speaker1(state, phi)
    observe(S1, utterance)
    return { state, phi }

  }})
}, 10000);

var alpha2 = 1;
var speaker2 = function(state, phi) {
  Infer({model: function(){

    var utterance = sample(utterancePrior)
    var L1 = pragmaticListener(utterance)
    factor(alpha2 * L1.score({state, phi}))
    return reshapeUtt(utterance)

  }})
}

display("speaker thinks 1 heart, tries to appear nice")
var s2_nice  = speaker2(1, 0.05)
viz(s2_nice)

display("speaker thinks 1 heart, tries to appear informative")
var s2_informative  = speaker2(1, 0.95)
viz(s2_informative)

display("speaker thinks 1 heart, tries to appear both nice and informative")
var s2_both  = speaker2(1, 0.5)
viz(s2_both)
</code></pre>

<blockquote>
  <p><strong>Exercises</strong>:</p>
</blockquote>

<blockquote>
  <ol>
    <li>What does the pragmatic listener infer when she hears “not amazing”? How does the pragmatic listener interpret the other “indirect” utterances?</li>
    <li>Write a purely informative <code>speaker2</code>, who only cares about conveying the “state”, but knows that the pragmatic listener will reason about both phi and state. Does it make different predictions from the model defined above?</li>
    <li>Write a purely self-presentational <code>speaker2</code>, who only cares about conveying “phi”, but knows that the pragmatic listener will reason about both phi and state. Does it make different predictions from the model defined above?</li>
    <li>Write an alternative <code>speaker2</code> who, like <code>speaker1</code>, is <em>actually</em> both kind and informative (as opposed to the self-presentational speaker model above).  Does it make different predictions from the model defined above?</li>
  </ol>
</blockquote>


<hr>

<a href="/probLang/">Table of Contents</a>

      </div>
    </div>

    <footer class="site-footer">
  <a href="http://gscontras.github.io/probLang/" id="github-edit-link">Edit on Github</a>
</footer>

<script type="text/javascript">
  $("#github-edit-link").attr("href", github_page_url("/chapters/09-politeness.html"))
</script>


  </body>

</html>
